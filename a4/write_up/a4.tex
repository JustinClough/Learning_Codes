\documentclass[a4paper, 12pt]{article}
\author{Justin Clough, RIN:661682899}
\title{FEP Assignment 4}
\usepackage{geometry}
\usepackage{float}
\usepackage{subfigure}
\usepackage[justification=centering]{caption}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{listings}
\lstset{
    language=C++,
    numbers=left,
    tabsize=2,
    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    frame=single,
    breaklines=true,
}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{nameref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled]{algorithm2e}

\begin{document}
\maketitle

\newpage
\section{Introduction} \label{sec:intro}
The purpose of this project was to develop a Finite
Element Analysis (FEA) code that solves linear
elliptic problems. This project does so for
three dimensional solid mechanic problems. The user
provides the code with the following information
(an example input script is shown in
Appendix \ref{subsec:ExIn}):

\begin{itemize}
  \item A geometric model of the domain in the
        form of a \emph{.dmg} file.
  \item The corresponding mesh of the domain in the
        from of a \emph{.smb} file.
  \item An associations file which define geometric
        node sets in the form of a \emph{.txt} file. The
        details of this file are explained in detail in
        section \ref{sec:codeDes}.
  \item A control file which define material properties,
        boundary conditions, and linear algebra details in
        the form of a \emph{.yaml} file.
  \item A file name to write the solution to as an array of
        characters.
  \item The order of numerical integration as an integer.
  \item The body load in the form of three floating point
        number.
\end{itemize}

Based on these input parameters, the code assembles and
solves the relevant finite element problem to retrieve
the displacement at each mesh Degree of Freedom (DOF).
It then calculates the Cauchy stress tensor for each
integration point of each element. It finally writes
the displacement, traction, and Cauchy stress fields to
file in \emph{.vtk} format.

The rest of this report is separated into the following
section. The technical description of the code, which
includes an overview of the Finite Element Method (FEM),
the numerical integration techniques used, and the
linear algebra assembly and solution methods is shown in
section \ref{sec:techDes}. A description of the code, which
includes an outline of classes created and a pseudo code
is shown in section \ref{sec:codeDes}. The tests performed
are described in section \ref{sec:testing}. Finally,
conclusions and closing comments are made
in \ref{sec:conclusion}. The source code and headers
are appended to this report in Appendix \ref{sec:code}.

\section{Technical Description} \label{sec:techDes}
The purpose of the code is to approximate the displacement
$u$ subjected to the conditions shown in Equations
\ref{eq:StrongForm} through \ref{eq:Compliance}:

\begin{align}
\sigma_{ij},_{j} - f_i &= 0  &  &\text{on} \quad  \Omega
  \label{eq:StrongForm}                                          \\
u_i &= g_i                   &  &\text{on} \quad \Gamma^{g}_{i}
  \label{eq:DBC}                                                 \\
\sigma_{ij} \cdot n_j &= h_i &  &\text{on} \quad \Gamma^{h}_{i}
  \label{eq:NBC}                                                 \\
\varepsilon_{ij} &= u_{i},_{j}&  &\quad
  \label{eq:strainDef}                                           \\
\sigma_{ij} &= c_{ijkm} \varepsilon_{km} & &\quad
  \label{eq:Compliance}
\end{align}

\noindent
where $\sigma$ is the Cauchy stress tensor in
the domain $\Omega$, $f$ is the
vector-valued traction, and $\varepsilon$ is the strain.
The subscripts indicate the spatial dimension of the vector or
tensor they follow and range from 1 to $n_{sd}$, the number
of spatial dimensions; summation is implied for repeated
indices. The vector $n$ is the outward normal on the pertinent surface
The domain $\Omega$ is bounded by boundaries
$\Gamma^{g}$ and $\Gamma^{h}$ as shown
in Equations \ref{eq:OmegaUnion} through \ref{eq:GammaUnion}:

\begin{align}
\Omega &= \hat{\Omega} \cup \Gamma
  \label{eq:OmegaUnion}               \\
\Gamma &= \bigcup_{i=1}^{n_{sd}} \Gamma^{g}_{i} \cup \Gamma^{h}_{i}
  \label{eq:GammaUnion}
\end{align}

\noindent
where $\Gamma$ is the total boundary of domain $\Omega$
and $\hat{\Omega}$ is the internal portion of $\Omega$.
The super scripts, $g$ and $h$ correspond
to the Dirichlet and Neumann boundary conditions shown in Equations
\ref{eq:DBC} and \ref{eq:NBC}, respectively. Dirichlet boundary
conditions prescribe the vector components of a
displacement on a given surface.
Neumann boundary conditions prescribe the components of a
traction on a given surface.  The Dirichlet and
Neumann boundary conditions are not defined on the same location
for the same spatial dimension, as shown in Equation \ref{eq:DNconf}.

\begin{equation} \label{eq:DNconf}
\Gamma^{g}_{i} \cap \Gamma^{h}_{j} = \varnothing \quad \text{if} \quad i=j
\end{equation}

The compliance tensor, $c$ relates the stain and stress by
material properties. This application assumed that the material
was isotropic and homogeneous. With these assumptions,
Equation \ref{eq:Compliance} formed Equation \ref{eq:StressStrain}:

\begin{equation} \label{eq:StressStrain}
s_{i} = D_{ij} e_{j}
\end{equation}

\noindent
where $s$ is the Nye-Notation form of $\sigma$; $e$ is the Nye-Notation
of $\varepsilon$ except that the shear strains are doubled. This
is shown in Equation \ref{eq:StrainVecDef}.

\begin{equation} \label{eq:StrainVecDef}
  \begin{bmatrix}
    e_1 \\
    e_2 \\
    e_3 \\
    e_4 \\
    e_5 \\
    e_6 \\
  \end{bmatrix}
  =
  \begin{bmatrix}
    \varepsilon_{11} \\
    \varepsilon_{22} \\
    \varepsilon_{33} \\

    2 \varepsilon_{23} \\
    2 \varepsilon_{13} \\
    2 \varepsilon_{12} \\
  \end{bmatrix}
\end{equation}

\noindent
The material stiffness tensor $D$ for this application
is shown in Equation \ref{eq:MatStiff}:

\begin{equation} \label{eq:MatStiff}
  D =
  \begin{bmatrix}
  \lambda+2\mu & \lambda      & \lambda      & 0 & 0 & 0 \\
  \lambda      & \lambda+2\mu & \lambda      & 0 & 0 & 0 \\
  \lambda      & \lambda      & \lambda+2\mu & 0 & 0 & 0 \\
  0 & 0 & 0 & \mu & 0 & 0 \\
  0 & 0 & 0 & 0 & \mu & 0 \\
  0 & 0 & 0 & 0 & 0 & \mu
  \end{bmatrix}
\end{equation}

\noindent
where $\lambda$ and $\mu$ are the Lam\'e parameters.
These parameters are based on the material properties $E$ and $\nu$
as shown in Equations \ref{eq:LameLambda} and \ref{eq:LameMu}:

\begin{align}
\lambda &= \frac{ \nu E }{(1+\nu) (1-2\nu) }
  \label{eq:LameLambda} \\
\mu &= \frac{ E}{ 2( 1+\nu)}
  \label{eq:LameMu}
\end{align}

\noindent
where $E$ and $\nu$ are the Young's Modulus and Poisson Ratio
of the material, respectively.

\subsection{Finite Element Method} \label{subsec:fem}
The relations shown in Equations \ref{eq:StrongForm} through
\ref{eq:Compliance} make up the strong form of the problem.
The weak form is shown in Equation \ref{eq:WeakForm}:

\begin{equation} \label{eq:WeakForm}
\int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega =
  \int_{\Omega} w_{i} f_{i} d\Omega +
  w_{i}\Big|_{\Gamma^{h}_{i}} h_{i}
\end{equation}

\noindent
where $w$ is a weighting function subject to the constraints
expressed in Equation \ref{eq:WConsts}.

\begin{equation} \label{eq:WConsts}
w_{i} \in H^1,\quad w_{i}\Big|_{\Gamma^{g}_{i}} = 0
    \quad \forall \quad i=1(1)n_{sd}
\end{equation}

\noindent
In Equation \ref{eq:WConsts}, $H^{1}$ is the order-one Hilbert space.
A derivation from the strong form is shown in Appendix \ref{sec:WeakDer}.
This weak form can then be approximated by a Galerkin form. 
The Galerkin form of this problem is shown in Equation 
\ref{eq:GalerkinForm} and is subject to the constraints and definitions
shown in Equations \ref{eq:GalerkinCont}
through  \ref{eq:GalerkinContFin}.

\begin{equation} \label{eq:GalerkinForm}
a(w^{h} , v^{h})
  = b(w^{h} , f) 
  + w^{h}_{i}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a(w^{h}\Big|_{\Gamma^{g}_{i}} , g^{h})
\end{equation}

\begin{align} 
a( X, Y ) &= 
  \int_{\Omega} c_{ijkm} X_{i},_{j} Y_{k},_{m} d\Omega 
    \label{eq:GalerkinCont}                                           \\
b( X, Y ) &= 
  \int_{\Omega} X_{i} Y_{i} d\Omega 
    \label{eq:GalerkinForce}                                          \\
u^{h}_{i} &= 
  v^{h}_{i} + g^{h}_{i} 
  \label{eq:GalerkinUh}                                               \\
g^{h}_{i}\Big|_{\Gamma^{g}_{i}} = g_{i} 
  \quad & \quad
  v^{h}_{i}\Big|_{\Gamma^{g}_{i}} = 0
  \label{eq:GalerkinContFin}                                       %\\
\end{align}

\noindent
A derivation form the weak from to this Galerkin form 
is available in Appendix \ref{sec:GalerkinDer}.
In Equation \ref{eq:GalerkinForm}, $u^{h}$ is the discrete
approximation of $u$ on a discretized $\Omega$, $\Omega_h$. Similarly,
$w^{h}$ is the discrete approximation of $w$ on the same 
discretized $\Omega$. The discrete approximation of
the displacement, $u^{h}$, is the sum of unknown, $v^{h}$, 
and given, $g^{h}$, displacement values. 

As part of the discretization of $\Omega$, shape functions
($N^{A}(x)$'s) are used to interpolate values. Here, $x$
is a vector describing any position in $\Omega$ and has members $x_i$. 
Details of the shape functions used discussed in section \ref{subsec:numInt}.
These shape functions are then used shown in in Equations
\ref{eq:shapeStart} through \ref{eq:shapeEnd}:

\begin{align}
w^{h}_i &= \sum_{A=1}^{n} c^{A}_i N^{A} 
  \label{eq:shapeStart}                       \\
v^{h}_i &= \sum_{A=1}^{n} d^{A}_i N^{A} 
  \label{eq:shapeUnks}                         \\
g^{h}_i &= \sum_{A=1}^{n} g^{A}_i N^{A} 
  \label{eq:shapeEnd}
\end{align}

\noindent
where $n$ is the number of discrete evaluation points, or nodes,
of $\Omega_h$. The $c^{A}_{i}$'s are arbitrary multipliers. From this, a matrix 
form of the problem can be created which is expressed in 
Equation \ref{eq:MatrixForm}:

\begin{equation} \label{eq:MatrixForm}
a( N^A, N^B) d^{B}_{i} = 
  b( N^A, f) +
  N^A\Big|_{\Gamma_{i}^{h}} h_i -
  a( N^A\Big|_{\Gamma_{i}^{g}} , N^C\Big|_{\Gamma_{i}^{g}} ) g_{i}^C
\end{equation} 

\noindent 
where $A$, $B$, and $C$ represent the set of nodes as described in 
Equation \ref{eq:nodesConds}.

\begin{align}
A &\in \eta - \eta_g
  \nonumber         \\
B &\in \eta - \eta_g
  \nonumber         \\
C &\in \eta_g
  \label{eq:nodesConds}
\end{align}

\noindent
In Equation set \ref{eq:nodesConds}, $\eta$ is the set of all nodes on $\Omega_h$ 
and $\eta_g$ is the subset of $\eta$ on which Dirichlet boundary conditions are 
prescribed. Equation \ref{eq:MatrixForm} can then be rewritten as shown in
Equation \ref{eq:KdF}.

\begin{equation} \label{eq:KdF}
[ K_{AB} ] \{ d_B \} = \{ F_A \} 
\end{equation}

\noindent
In Equation \ref{eq:KdF}, $[K]$ is the stiffness matrix component 
relating the degree of freedom of the node at row $A$ to the degree of freedom 
of the node at column $B$. The vector $\{d\}$ is comprised of all unknown 
nodal displacements of the degrees of freedom in $\Omega_h$. The 
vector $\{F\}$ is comprised of all the nodal force components in $\Omega_h$.
A derivation from the Galerkin form shown in Equation \ref{eq:GalerkinForm}
to the matrix form shown in Equation \ref{eq:MatrixForm} is available in Appendix
\ref{sec:MatrixDer}. For situations where $\Omega_h$ is discretized with 
multiple elements, stiffness and force values are summed at each node.

\subsection{Numerical Integration} \label{subsec:numInt}
Gaussian quadrature was used to approximate all integrated 
values in this project. This includes stiffness terms
for the elemental stiffness matrices and the elemental force vector components
from both traction boundary conditions. 
A numerical approximation of an integral takes the form shown in 
Equation \ref{eq:NumInte}:

\begin{equation} \label{eq:NumInte}
\int_{\Omega} p(x) d\Omega 
  = \sum_{n_{int}=1}^{N_{int}} p(x\Big|_{n_{int}}) W_{n_{int}} + R 
  \approx \sum_{n_{int}=1}^{N_{int}} p(x\Big|_{n_{int}}) W_{n_{int}}
\end{equation}

\noindent
where $p(x)$ is the function to integrate, $N_{int}$ is the total number 
of integration points, $W_{n_{int}}$ is the weight at each integration point, 
and $R$ is the error in approximating the continuous integral numerically.
This error decreases as a higher order of integration is used and was
approximated as zero to evaluate calculations.
The integration point weights and locations are dependent on the order of
approximation and the approximation method. Gaussian quadrature was
used for this project. The approximation shown in Equation \ref{eq:NumInte}
for three dimensions is shown in Equation \ref{eq:3DNumInte}.

\begin{equation} \label{eq:3DNumInte}
\iiint_{\Omega} p(x_1, x_2, x_3) d\Omega \approx 
  \sum_{n^1_{int}=1}^{N^1_{int}} 
  \sum_{n^2_{int}=1}^{N^2_{int}} 
  \sum_{n^3_{int}=1}^{N^3_{int}} 
  p(x_1\Big|_{n^1_{int}}, 
  x_2\Big|_{n^2_{int}}, 
  x_3\Big|_{n^3_{int}})
  W_{n^1_{int}}
  W_{n^2_{int}}
  W_{n^3_{int}}
\end{equation}

The numerical integration took place on a parametric space, $\Box$, that represented each 
element and used a mapping to return to the domain, $\Omega_h$. 
The mapping between real and parametric domains is described in 
Equations \ref{eq:Mapping} through \ref{eq:jacobian}.

\begin{align} 
x   &= (x_1, x_2, x_3) \in \hat{\Omega}
  \label{eq:Mapping} \\
\xi &= (\xi_1, \xi_2, \xi_3) \in \Box \\
J &= det
  \begin{bmatrix}
    \frac{\partial x_1}{\partial \xi_1} & 
      \frac{\partial x_1}{\partial \xi_2} & 
      \frac{\partial x_1}{\partial \xi_3} \\
    \frac{\partial x_2}{\partial \xi_1} & 
      \frac{\partial x_2}{\partial \xi_2} & 
      \frac{\partial x_2}{\partial \xi_3} \\
    \frac{\partial x_3}{\partial \xi_1} & 
      \frac{\partial x_3}{\partial \xi_2} & 
      \frac{\partial x_3}{\partial \xi_3} \\
  \end{bmatrix}
  \label{eq:jacobian}
\end{align}

\noindent
The variable $J$ is the Jacobian determinant and represents
the volumetric dilation from $\Box$ to $\Omega_h$ for a given location $\xi$.
Combining the mapping shown in Equations \ref{eq:Mapping} through
\ref{eq:jacobian} with the three dimensional numerical 
integration technique shown in Equation \ref{eq:3DNumInte} yield
Equation \ref{eq:J_numInt}.

\begin{multline} \label{eq:J_numInt}
\iiint_{\Omega} p(x_1, x_2, x_3) d\Omega
  \approx \\
  \sum_{n^1_{int}=1}^{N^1_{int}} 
  \sum_{n^2_{int}=1}^{N^2_{int}} 
  \sum_{n^3_{int}=1}^{N^3_{int}} 
  p(
  x_1(\xi\Big|_{n^1_{int}}),
  x_2(\xi\Big|_{n^2_{int}}),
  x_3(\xi\Big|_{n^3_{int}}))
  J( \xi\Big|_{n^3_{int}})
  W_{n^1_{int}}
  W_{n^2_{int}}
  W_{n^3_{int}}
\end{multline}

Shape functions were used to interpolate quantities between the
nodes of $\Omega_h$. 

%TODO

\subsection{Linear Algebra} \label{subsec:LinAlg}
The entirety of the stiffness matrix was not stored as it is 
sparsely populated. Instead, the matrix was stored as a collection
of arrays using compressed row storage. 
Each array represented a row in the stiffness matrix. 
The elements of each array stored the non-zero value and column index of the 
matrix element it represented. This project made use 
of the implementation available through \texttt{TPetra}.

The Generalized Minimal Residual (GMRES) method was used to solve 
the system described in Equation \ref{eq:KdF}. Specifically
the implementation from the \texttt{Belos} package was used.  
The GMRES is an iterative method; for this project a maximum 
iteration limit of 200 was used with a tolerance of $10^{-10}$.

\section{Code Description} \label{sec:codeDes}
Code description here.

\subsection{Class Description} \label{subsec:class}
Class description text here.

\subsection{Pseudo Code} \label{subsec:pseudo}
The main code is shown in Algorithm \ref{al:main}. For all 
algorithms presented in the this section, namespaces 
are not shown for brevity. Algorithm blocks which 
show the pseudo codes for subroutines written for this 
project are shown after Algorithm \ref{al:main}. 
Pseudo code for functions and methods not written for this 
project but borrowed from other libraries, like \texttt{PUMI},
\texttt{APF}, and \texttt{Trilinos}, are not shown.

\vspace{\baselineskip}
\begin{algorithm} [H] 
  \underline{main} $(int \quad argc, \quad char** \quad argv)$ 
  \BlankLine
    \tcc
    {
      Create a parameter list object and populate with information
      from yaml file.
    }
    ParameterList p\;
    updateParametersFromYaml( $<$yamlFile$>$, p)\;
    \tcc
    { 
      Load the mesh from file.
    }
    m = loadMdsMesh( $<$modelFileName$>$.dmg, $<$meshFileName$>$.smb)\;
    \tcc
    { 
      Create a discretization-class object based on the mesh
      and the associations file.
    }
    d = createDiscretization( m, $<$associationsFile$>$)\;
    \tcc
    {
      Create a solver-class object, then solve the FE system.
      The system is solved using the GMRES method discussed
      in subsection \ref{subsec:LinAlg} using the
      \texttt{Belos} software package.
    }
    s = createSystemSolver( d, p, integration\_order, body\_load)\;
    s$\rightarrow$ solve()\;
    \tcc
    {
      Create and populate fields with solution information. 
      Write to Vtk file. (Note: 3 is the dimension in writeVtkFiles.)
    }
    s$\rightarrow$ set\_displacement\_to\_field()\;
    s$\rightarrow$ set\_traction\_to\_field()\;
    s$\rightarrow$ set\_stress\_to\_field()\;
    writeVtkFiles( $<$FileName$>$, m, 3)\;
    \tcc
    {
      Allocated memory space is freed.
    }
    return 0 \;
  \caption{The main function for this project. The function takes 10 
            arguments which are described in section \ref{sec:intro}.}
  \label{al:main}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{createDiscretization} $(mesh* \quad m, char* \quad <associationsFile>)$
  \BlankLine
  \tcc
  {
    Verify the mesh is usable; abort program otherwise.
  }
  m$\rightarrow$ verify()\;
  \tcc
  {
    Compute maps and node sets for creating the linear algebra data types
    and assigning boundary conditions.
  }
  compute\_maps()\;
  compute\_sets()\;
  return\;
  \caption{Constructor for the discretization object.}
  \label{al:creatDisc}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}
  \underline{discretization::compute\_maps} $()$
  \BlankLine
  get\_number\_nodes( mesh)\;
  numbering = create\_new\_numbering( mesh)\;
  \For{Each Node}
  {
    \tcc
    {
      Assign each node a unique global identification number.
    }
    assign\_node\_ID( this\_node, numbering)\;
  }
  create\_map\_outline( numbering)\;
  \For{Each Node}
  {
    \For{Each Nodal Degree of Freedom}
    {
      assign\_map\_value()\;
    }
  }
  return;
  \caption{Member function of the discretization object that constructs
            the maps needed to create the sparse stiffness matrix, solution,
            and forcing vector.}
  \label{al:compMaps}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}
  \underline{discretization::compute\_sets} $()$
  \BlankLine
  \For{Each Set Declared in yaml}
  {
    \For{Each Mesh Entity of Defined Dimension}
    {
      get\_classification( mesh\_entity)\;
      \If{ Geometric Entity Needs Set From yaml}
      {
        \tcc
        {
          Add this mesh entity to a list for this set.
        }
      }
    }
  }
  return\;
  \caption{Member function of the discretization object that constructs
            node sets for assigning boundary conditions.}
  \label{al:compSets}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{solver::solve} $()$
  \BlankLine
  \tcc
  {
    Assemble the unreduced stiffness matrix and forcing vector.
  }
  assemble\_Left\_Hand\_Side()\;
  assemble\_Right\_Hand\_Side()\;
  \tcc
  {
    Apply Dirichlet boundary conditions to the system.
  }
  apply\_Dirichlet\_BCs()\;
  \tcc
  {
    Solve the $Kd=F$ system iteratively using GMRES method.
  }
  solve\_linear\_system()\;
  return\;
  \caption{Method for creating and then solving the finite element system.}
  \label{al:solve}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{solver::assemble\_Left\_Hand\_Side} $()$
  \BlankLine
  get\_material\_properties()\;
  \For{Each Mesh Element}
  {
    integrate\_elastic\_stiffness()\;
    get\_element\_node\_IDs()\;
    \For{Each Nodal Degree of Freedom}
    {
      get\_global\_row\_number()\;
      sum\_elemental\_into\_global\_stiffness()\;
    }
  }
  return\;
  \caption{Method for creating the unreduced stiffness matrix accounting
          for the final system begin sparsely populated.}
  \label{al:AssembleLHS}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{solver::assemble\_Right\_Hand\_Side} $()$
  \BlankLine
  \tcc
  {
    Neumann boundary conditions are first evaluated, 
    then body loads. This order is arbitrary.
  }
  \For{Each Neumann Boundary Condition from yaml}
  {
    get\_traction\_vector()\;
    \tcc
    {
      The sets computed earlier in Algorithm \ref{al:compSets}
      are used here to quickly 
      retrieve the list of mesh entities on the boundary 
      that need to be evaluated.
    }
    get\_boundary\_mesh\_entities()\;
    \For{Each Mesh Entity}
    {
      integrate\_traction()\;
      get\_element\_node\_IDs()\;
      \For{Each Nodal Degree of Freedom}
      {
        get\_global\_row\_number()\;
        sum\_elemental\_into\_global\_forcing()\;
      }
    }
  }
  \For{Each Mesh Region}
  {
    integrate\_body\_load()\;
    get\_element\_node\_IDs()\;
    \For{Each Nodal Degree of Freedom}
    {
      get\_global\_row\_number()\;
      sum\_elemental\_into\_global\_forcing()\;
    }
  }
  return\;
  \caption{Method for creating the forcing vector based on Neumann boundary 
            conditions and body loads.}
  \label{al:AssembleRHS}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm} 
  \underline{integrate\_body\_load} $()$
  \BlankLine
  \For{Each Integration Point}
  {
    p = get\_parametric\_location()\;
    w = get\_point\_weight(p)\;
    dv= get\_det\_J(p)\;
    N = get\_basis\_func(p)\;
    \For{Each Element Node}
    {
      \For{Each Degree of Freedom}
      {
        $f_{tmp}(i) \leftarrow f_{tmp}(i) + N(i) * g(i) * w * dv$ \;
        \tcc
        {
          Where "g" is the vector of body loads.
        }
      }
    }

    $F_e \leftarrow F_e + f_{tmp}$\;
  }
  return;
  \caption{Integration method to construct elemental forcing vector
            contributions due to Neumann boundary conditions.}
  \label{al:BLC_int}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm} 
  \underline{integrate\_traction} $()$
  \BlankLine
  \For{Each Integration Point}
  {
    p = get\_parametric\_location()\;
    w = get\_point\_weight(p)\;
    dv= get\_det\_J(p)\;
    N = get\_basis\_func(p)\;
    \For{Each Element Node}
    {
      \For{Each Degree of Freedom}
      {
        $f_{tmp}(i) \leftarrow f_{tmp}(i) + N(i) * T(i) * w * dv$ \;
        \tcc
        {
          Where "T" is the vector of tractions.
        }
      }
    }

    $F_e \leftarrow F_e + f_{tmp}$\;
  }
  return\;
  \caption{Integration method to construct elemental forcing vector
            contributions due to Neumann boundary conditions.}
  \label{al:NBC_int}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}
  \underline{integrate\_elastic\_stiffness} $()$
  \BlankLine
  D = fill\_material\_elasticity\_tensor()\;
  \For{Each Integration Point}
  {
    p = get\_parametric\_location()\;
    w = get\_point\_weight(p)\;
    dv= get\_det\_J(p)\;
    B = get\_basis\_func\_gradient(p)\;
    $k_{tmp}$ $\leftarrow$ $B^{T}*D*B*w*dv$\;
    $K_e \leftarrow K_e + k_{tmp}$\;
  }
  return\;
  \caption{Integration method to construct elemental stiffness matrices.}
  \label{al:KE_int}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{solver::apply\_Dirichlet\_BCs} $()$
  \BlankLine
  \For{Each Dirichlet Boundary Condition from yaml}
  {
    get\_displacement\_vector()\;
    \tcc
    {
      The sets computed earlier in Algorithm \ref{al:compSets}
      are used here to
      retrieve the list of mesh entities on the boundary 
      that need to be evaluated.
    }
    get\_boundary\_mesh\_entities()\;
    \For{Each Mesh Entity}
    {
      get\_element\_node\_IDs();
      \For{Each Nodal Degree of Freedom}
      {
        \tcc
        {
          All row entries but the diagonal term for this 
          row of the stiffness matrix are set to zero. The
          diagonal term is set to one and the old diagonal 
          term is multiplied by the displacement component
          for this degree of freedom and placed into the 
          forcing vector.
        }
        tmp = get\_global\_stiffness\_diagonal()\;
        \For{Each Non-Zero Row Entry}
        {
          \If{ $row == column$}
          {
            set\_stiffness(row, column, 1.0)\;
            set\_force( row, tmp*displacement)\;
          }
          \Else
          {
            set\_stiffness(row, column, 0.0)\;
          }
        }
      }
    }
  }
  return\;
  \caption{Method for adjusting stiffness matrix and force vector for 
            Dirichlet boundary conditions.}
  \label{al:ApplyDBCs}
\end{algorithm}

\vspace{\baselineskip}
\begin{algorithm}[H]
  \underline{solver::set\_$<*>$\_to\_field} $()$
  \BlankLine
  get\_mesh\_nodes();
  \For{Each Node}
  {
    \For{Each Nodal Degree of Freedom}
    {
      \tcc
      {
        The value that the field represents (displacement,
        traction, or stress) is gotten here.
      }
      get\_solution\_component()\;
      set\_component\_to\_field()\;
    }
  }
  \caption{Generic function for setting a vector or matrix solution to a field
            that can then be written to a Vtk file for use with ParaView.}
  \label{al:set_to_field}
\end{algorithm}
\vspace{\baselineskip}

\section{Testing} \label{sec:testing}
Testing text here.

\subsection{Linear Tetrahedron Elements} \label{subsec:linTet}
Linear Tri element text here.

Convergence of linear tet elements here.

\subsection{Linear Hexahedron Elements} \label{subsec:linHex}
Linear quad text here.

\subsection{Quadratic Tetrahedron Elements} \label{subsec:quadTet}
Quadratic Tri element text here.

Convergence of quad tets here.

\subsection{Quadratic Hexahedron Elements} \label{subsec:quadHex}
Quadratic quad element text here.

\section{Conclusion} \label{sec:conclusion}
conclusion text here.

\subsection{Closing Comments} \label{sec:comments}
closing comments here.

\newpage
\appendix
\section{Source Code and Headers} \label{sec:code}

\subsection{a4.cc} \label{subsec:a4.cc}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/a4.cc}

\subsection{A4\_BodyLoads.hpp} \label{subsec:BLhpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_BodyLoads.hpp}

\subsection{A4\_BodyLoads.cpp} \label{subsec:BLcpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_BodyLoads.cpp}

\subsection{A4\_Control.hpp} \label{subsec:Cont.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_Control.hpp}

\subsection{A4\_Control.cpp} \label{subsec:Cont.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_Control.cpp}

\subsection{A4\_DBCs.hpp} \label{subsec:DBCs.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_DBCs.hpp}

\subsection{A4\_DBCs.cpp} \label{subsec:DBCs.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_DBCs.cpp}

\subsection{A4\_Disc.hpp} \label{subsec:Disc.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_Disc.hpp}

\subsection{A4\_Disc.cpp} \label{subsec:Disc.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_Disc.cpp}

\subsection{A4\_ElasticStiffness.hpp} \label{subsec:ElasticStiffness.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_ElasticStiffness.hpp}

\subsection{A4\_ElasticStiffness.cpp} \label{subsec:ElasticStiffness.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_ElasticStiffness.cpp}

\subsection{A4\_FESolver.hpp} \label{subsec:FESolver.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_FESolver.hpp}

\subsection{A4\_FESolver.cpp} \label{subsec:FESolver.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_FESolver.cpp}

\subsection{A4\_LinAlg.hpp} \label{subsec:LinAlg.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_LinAlg.hpp}

\subsection{A4\_LinAlg.cpp} \label{subsec:LinAlg.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_LinAlg.cpp}

\subsection{A4\_LinSolve.hpp} \label{subsec:LinSolve.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_LinSolve.hpp}

\subsection{A4\_LinSolve.cpp} \label{subsec:LinSolve.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_LinSolve.cpp}

\subsection{A4\_NBCs.hpp} \label{subsec:NBCs.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_NBCs.hpp}

\subsection{A4\_NBCs.cpp} \label{subsec:NBCs.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_NBCs.cpp}

\subsection{A4\_PostProc.hpp} \label{subsec:PostProc.hpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_PostProc.hpp}

\subsection{A4\_PostProc.cpp} \label{subsec:PostProc.cpp}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/src/A4_PostProc.cpp}

\newpage
\section{Example Input Files}\label{sec:ExInput}

\subsection{Associations File} \label{subsec:ExAssoc}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/test/box3D.txt}

\subsection{Example .yaml File} \label{subsec:ExYaml}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/test/fem.yaml}

\subsection{Example Input Script} \label{subsec:ExIn}
\lstinputlisting{/lore/clougj/FiniteElementProgramming/a4/test/run_test.sh}

\newpage
\section{Derivations} \label{sec:Derivations}

\subsection{Strong to Weak Form Derivation} \label{sec:WeakDer}

Given:
\begin{equation*}
\sigma_{ij},_{j} - f_{i} = 0 \quad \text{and} \quad
w_{i} \in H^1, w_{i}\Big|_{\Gamma^{g}_{i}} = 0
    \quad \forall \quad i=1(1)n_{sd}
\end{equation*}

\begin{equation*}
\sigma_{ij},_{j} = c_{ijkm} \varepsilon_{km} = c_{ijkm} u_{k},_{m}
\end{equation*}

\noindent
Solution:

\begin{align*}
\int_{\Omega} w_{i} c_{ijkm} u_{k},_{mj} d\Omega - 
  \int_{\Omega} w_{i} f_{i} d\Omega &= 0 \\
-c_{ijkm}(w_{i} u_{k},_{mj})\Big|_{\partial\Omega = \Gamma} 
  + \int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega
  &=\int_{\Omega} w_{i} f_{i} d\Omega  \\
-c_{ijkm}(w_{i} u_{k},_{mj})\Big|_{\Gamma^{g}_{i}} 
-c_{ijkm}(w_{i} u_{k},_{mj})\Big|_{\Gamma^{h}_{i}} 
  + \int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega
  &=\int_{\Omega} w_{i} f_{i} d\Omega \\
0
 -c_{ijkm}(w_{i} u_{k},_{mj})\Big|_{\Gamma^{h}_{i}} 
  + \int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega
  &=\int_{\Omega} w_{i} f_{i} d\Omega \\
-w_{i}\Big|_{\Gamma^{h}_{i}} h_{i}
  + \int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega
  &=\int_{\Omega} w_{i} f_{i} d\Omega \\
\int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega &=
  \int_{\Omega} w_{i} f_{i} d\Omega +
  w_{i}\Big|_{\Gamma^{h}_{i}} h_{i}
\end{align*}

\newpage
\subsection{Weak to Galerkin Form Derivation} \label{sec:GalerkinDer}

Given:
\begin{align*}
a( X, Y ) &= 
  \int_{\Omega} c_{ijkm} X_{i},_{j} Y_{k},_{m} d\Omega \\
b( X, Y ) &= 
  \int_{\Omega} X_{i} Y_{i} d\Omega \\
u^{h}_{i} = 
  v^{h}_{i} + g^{h}_{i} 
  \quad
  g^{h}_{i}\Big|_{\Gamma^{g}_{i}} &= g_{i} 
  \quad 
  v^{h}_{i}\Big|_{\Gamma^{g}_{i}} = 0
\end{align*}

\noindent
Solution:

\begin{align*}
\int_{\Omega} c_{ijkm} w_{i},_{j} u_{k},_{m} d\Omega 
 &= \int_{\Omega} w_{i} f_{i} d\Omega
  + w_{i}\Big|_{\Gamma^{h}_{i}} h_{i} \\
a(w, u)
 &= b(w , f) 
  + w_{i}\Big|_{\Gamma^{h}_{i}} h_{i}  \\
\text{let} \quad u &\approx u^{h} = v^{h} + g^{h} \\
 \quad w &\approx w^{h} \\
a(w^{h} , u^{h} ) 
 &= b(w^{h}, f) 
  + w^{h}_{i}\Big|_{\Gamma^{h}_{i}} h_{i}  \\
a(w^{h} , v^{h} ) 
  + a(w^{h} , g^{h} ) 
 &= b(w^{h}, f) 
  + w^{h}_{i}\Big|_{\Gamma^{h}_{i}} h_{i}  \\
a(w^{h} , v^{h})
 &= b(w^{h} , f) 
  + w^{h}_{i}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a(w^{h} , g^{h})
\end{align*}

\newpage
\subsection{Galerkin to Matrix Form Derivation} \label{sec:MatrixDer}

Given:
\begin{equation*}
a(w^{h} , v^{h})
 = b(w^{h} , f) 
  + w^{h}_{i}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a(w^{h} , g^{h})
\end{equation*}

\begin{align*}
w^{h}_i &= \sum_{A=1}^{n} c^{A}_i N^{A}  \\
v^{h}_i &= \sum_{A=1}^{n} d^{A}_i N^{A}  \\
g^{h}_i &=  \sum_{A=1}^{n} g^{A}_i N^{A}
\end{align*}

\noindent
Solution:

\begin{equation*}
a(c^{A} N^{A}, d^{B} N^{B})
 = b( c^{A} N^{A} , f) 
  + c^{A} N^{A}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a( c^{A} N^{A}, g^{C} N^{C})
\end{equation*}

\begin{equation*}
c^{A} a(N^{A}, N^{B})d^{B} 
 = c^{A} b( N^{A} , f) 
  + c^{A} N^{A}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - c^{A}a( N^{A}, N^{C})g^{C} 
\end{equation*}

\begin{equation*}
a(N^{A}, N^{B})d^{B} 
 = b( N^{A} , f) 
  + N^{A}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a( N^{A}, N^{C})g^{C} 
\end{equation*}

\begin{align*}
\text{Let}\quad K_{AB} &= a(N^{A}, N^{B}) \\
F_A &= b( N^{A} , f) 
  + N^{A}\Big|_{\Gamma^{h}_{i}} h_{i} 
  - a( N^{A}, N^{C})g^{C} 
\end{align*}

\begin{equation*}
[ K_{AB} ] \{ d_B \} = \{ F_A \} 
\end{equation*} 

\end{document}
